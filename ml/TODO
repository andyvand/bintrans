-*- text -*-

ROADMAP:

* make all ppc compare instructions generated by mlgen.

* make all ppc cr* instructions generated by mlgen.

* add overflow and carry and add all *o and *c instructions.

* figure out how to handle ifs and branches and add branch instructions.

* add mf*/mt* instructions.

* add sraw*

* add another machine and another target.

* add common subexpr/substmt elimination.  this is especially important for
  ppc cr instructions and for i386 ea and cr calculation.

*** first step done.  write paper.

ROADMAP DONE:

* add KILL_* for registers and condition bit registers.

* make all ppc *. instructions generated by mlgen.

TODO:

* figure out a way for not having to specify in machine_ppc.lisp that
  the crfd field has to be iterated over to get correct code when
  mapping cr bits to registers.

* make upper alpha condition bit register bits known.  only the lowest bit is
  unknown, the others should be 0.

* apply a mask to the rhs of a condition bit assignment.  see FIXME comment in
  map_condition_bits in mapping.ml.

* implement a function determining if an expression is sexed or zexed and to
  how many bits.  this should replace our crazy sex optimization, which fails
  in some cases.

* implement special cases of Insert in alpha generator.

* make IntParityEven and IntSign unary instead of unary_width

* make LoadByte a normal load.  byte-order is to be ignored.  store
  works the same way.

* sex optimizer must not only try either all registers with zero or all with
  one but all combinations!

* add a matcher to alpha target which matches Sex(w,Extract(x,s,l)) with l ==
  w * 8 to generate sll->sra

* include fields in source machine description.  bits known to be zero
  should be communicated to known and bits.  then we wouldn't need,
  for example, zex in xori.

* when accessing ppc memory on the alpha, we need to sex or zex the address.
  we can do this by making the pruner prune addresses to alpha width (i.e. 8
  bytes) and making the alpha wrapper sex or zex the address.  note: the hand
  coded generator does not do this to improve efficiency, in the hope that it
  will not cause problems.

* add conditions to simplifiers, so that for example the sex(ashiftr(x))
  simplification can be made more generic.

* ask on comp.lang.functional about user op monad problem.

* sometimes we use width ops in bits and known.  the upper parts of the
  results of these are undefined, but known and bits need them defined!  apply
  a mask.


DONE:

   subl for subtraction and addition(!)

 ++++++++++++++++
 rlwinm r0,r0,8,24,31
 - - - - - - - - 
-extbl $9,3,$9
+zapnot $9,15,$9
+srl $9,24,$9
 ++++++++++++++++

remove IntSub and implement it with IntAdd/IntNeg.

* add an optimization that turns several different patterns into Extract and
  Insert:

     ++++++++++++++++
     rlwinm r0,r0,5,31,31
     - - - - - - - - 
    -sll $9,36,$9
    -srl $9,63,$9
    +zapnot $9,15,$1
    +srl $1,27,$1
    +and $1,1,$9
     ++++++++++++++++

* add If in a stmt, so we can have two cases for store with update
  insns - one with the store first and the other one with the update
  first (when the two registers are different):

   ++++++++++++++++
   stbu r11,-1(r4)
   - - - - - - - -
  -lda $1,-1($13)
  -xor $1,3,$2
  -stb $22,0($2)
  -subl $13,1,$13
  +lda $13,-1($13)
  +xor $13,3,$1
  +stb $22,0($1)
   ++++++++++++++++

OBSOLETE:

   lda for 64 bit subtraction (we don't have IntSub any more)
